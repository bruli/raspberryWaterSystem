// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package logger

import (
	"sync"
)

var (
	lockLoggerMockDebug       sync.RWMutex
	lockLoggerMockDebugf      sync.RWMutex
	lockLoggerMockEnableDebug sync.RWMutex
	lockLoggerMockFatal       sync.RWMutex
	lockLoggerMockFatalf      sync.RWMutex
	lockLoggerMockInfo        sync.RWMutex
	lockLoggerMockInfof       sync.RWMutex
)

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
//     func TestSomethingThatUsesLogger(t *testing.T) {
//
//         // make and configure a mocked Logger
//         mockedLogger := &LoggerMock{
//             DebugFunc: func(v ...interface{})  {
// 	               panic("mock out the Debug method")
//             },
//             DebugfFunc: func(format string, v ...interface{})  {
// 	               panic("mock out the Debugf method")
//             },
//             EnableDebugFunc: func()  {
// 	               panic("mock out the EnableDebug method")
//             },
//             FatalFunc: func(v ...interface{})  {
// 	               panic("mock out the Fatal method")
//             },
//             FatalfFunc: func(format string, v ...interface{})  {
// 	               panic("mock out the Fatalf method")
//             },
//             InfoFunc: func(v ...interface{})  {
// 	               panic("mock out the Info method")
//             },
//             InfofFunc: func(format string, v ...interface{})  {
// 	               panic("mock out the Infof method")
//             },
//         }
//
//         // use mockedLogger in code that requires Logger
//         // and then make assertions.
//
//     }
type LoggerMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(v ...interface{})

	// DebugfFunc mocks the Debugf method.
	DebugfFunc func(format string, v ...interface{})

	// EnableDebugFunc mocks the EnableDebug method.
	EnableDebugFunc func()

	// FatalFunc mocks the Fatal method.
	FatalFunc func(v ...interface{})

	// FatalfFunc mocks the Fatalf method.
	FatalfFunc func(format string, v ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(v ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, v ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// V is the v argument value.
			V []interface{}
		}
		// Debugf holds details about calls to the Debugf method.
		Debugf []struct {
			// Format is the format argument value.
			Format string
			// V is the v argument value.
			V []interface{}
		}
		// EnableDebug holds details about calls to the EnableDebug method.
		EnableDebug []struct {
		}
		// Fatal holds details about calls to the Fatal method.
		Fatal []struct {
			// V is the v argument value.
			V []interface{}
		}
		// Fatalf holds details about calls to the Fatalf method.
		Fatalf []struct {
			// Format is the format argument value.
			Format string
			// V is the v argument value.
			V []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// V is the v argument value.
			V []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// V is the v argument value.
			V []interface{}
		}
	}
}

// Debug calls DebugFunc.
func (mock *LoggerMock) Debug(v ...interface{}) {
	if mock.DebugFunc == nil {
		panic("LoggerMock.DebugFunc: method is nil but Logger.Debug was just called")
	}
	callInfo := struct {
		V []interface{}
	}{
		V: v,
	}
	lockLoggerMockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	lockLoggerMockDebug.Unlock()
	mock.DebugFunc(v...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//     len(mockedLogger.DebugCalls())
func (mock *LoggerMock) DebugCalls() []struct {
	V []interface{}
} {
	var calls []struct {
		V []interface{}
	}
	lockLoggerMockDebug.RLock()
	calls = mock.calls.Debug
	lockLoggerMockDebug.RUnlock()
	return calls
}

// Debugf calls DebugfFunc.
func (mock *LoggerMock) Debugf(format string, v ...interface{}) {
	if mock.DebugfFunc == nil {
		panic("LoggerMock.DebugfFunc: method is nil but Logger.Debugf was just called")
	}
	callInfo := struct {
		Format string
		V      []interface{}
	}{
		Format: format,
		V:      v,
	}
	lockLoggerMockDebugf.Lock()
	mock.calls.Debugf = append(mock.calls.Debugf, callInfo)
	lockLoggerMockDebugf.Unlock()
	mock.DebugfFunc(format, v...)
}

// DebugfCalls gets all the calls that were made to Debugf.
// Check the length with:
//     len(mockedLogger.DebugfCalls())
func (mock *LoggerMock) DebugfCalls() []struct {
	Format string
	V      []interface{}
} {
	var calls []struct {
		Format string
		V      []interface{}
	}
	lockLoggerMockDebugf.RLock()
	calls = mock.calls.Debugf
	lockLoggerMockDebugf.RUnlock()
	return calls
}

// EnableDebug calls EnableDebugFunc.
func (mock *LoggerMock) EnableDebug() {
	if mock.EnableDebugFunc == nil {
		panic("LoggerMock.EnableDebugFunc: method is nil but Logger.EnableDebug was just called")
	}
	callInfo := struct {
	}{}
	lockLoggerMockEnableDebug.Lock()
	mock.calls.EnableDebug = append(mock.calls.EnableDebug, callInfo)
	lockLoggerMockEnableDebug.Unlock()
	mock.EnableDebugFunc()
}

// EnableDebugCalls gets all the calls that were made to EnableDebug.
// Check the length with:
//     len(mockedLogger.EnableDebugCalls())
func (mock *LoggerMock) EnableDebugCalls() []struct {
} {
	var calls []struct {
	}
	lockLoggerMockEnableDebug.RLock()
	calls = mock.calls.EnableDebug
	lockLoggerMockEnableDebug.RUnlock()
	return calls
}

// Fatal calls FatalFunc.
func (mock *LoggerMock) Fatal(v ...interface{}) {
	if mock.FatalFunc == nil {
		panic("LoggerMock.FatalFunc: method is nil but Logger.Fatal was just called")
	}
	callInfo := struct {
		V []interface{}
	}{
		V: v,
	}
	lockLoggerMockFatal.Lock()
	mock.calls.Fatal = append(mock.calls.Fatal, callInfo)
	lockLoggerMockFatal.Unlock()
	mock.FatalFunc(v...)
}

// FatalCalls gets all the calls that were made to Fatal.
// Check the length with:
//     len(mockedLogger.FatalCalls())
func (mock *LoggerMock) FatalCalls() []struct {
	V []interface{}
} {
	var calls []struct {
		V []interface{}
	}
	lockLoggerMockFatal.RLock()
	calls = mock.calls.Fatal
	lockLoggerMockFatal.RUnlock()
	return calls
}

// Fatalf calls FatalfFunc.
func (mock *LoggerMock) Fatalf(format string, v ...interface{}) {
	if mock.FatalfFunc == nil {
		panic("LoggerMock.FatalfFunc: method is nil but Logger.Fatalf was just called")
	}
	callInfo := struct {
		Format string
		V      []interface{}
	}{
		Format: format,
		V:      v,
	}
	lockLoggerMockFatalf.Lock()
	mock.calls.Fatalf = append(mock.calls.Fatalf, callInfo)
	lockLoggerMockFatalf.Unlock()
	mock.FatalfFunc(format, v...)
}

// FatalfCalls gets all the calls that were made to Fatalf.
// Check the length with:
//     len(mockedLogger.FatalfCalls())
func (mock *LoggerMock) FatalfCalls() []struct {
	Format string
	V      []interface{}
} {
	var calls []struct {
		Format string
		V      []interface{}
	}
	lockLoggerMockFatalf.RLock()
	calls = mock.calls.Fatalf
	lockLoggerMockFatalf.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LoggerMock) Info(v ...interface{}) {
	if mock.InfoFunc == nil {
		panic("LoggerMock.InfoFunc: method is nil but Logger.Info was just called")
	}
	callInfo := struct {
		V []interface{}
	}{
		V: v,
	}
	lockLoggerMockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	lockLoggerMockInfo.Unlock()
	mock.InfoFunc(v...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//     len(mockedLogger.InfoCalls())
func (mock *LoggerMock) InfoCalls() []struct {
	V []interface{}
} {
	var calls []struct {
		V []interface{}
	}
	lockLoggerMockInfo.RLock()
	calls = mock.calls.Info
	lockLoggerMockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *LoggerMock) Infof(format string, v ...interface{}) {
	if mock.InfofFunc == nil {
		panic("LoggerMock.InfofFunc: method is nil but Logger.Infof was just called")
	}
	callInfo := struct {
		Format string
		V      []interface{}
	}{
		Format: format,
		V:      v,
	}
	lockLoggerMockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	lockLoggerMockInfof.Unlock()
	mock.InfofFunc(format, v...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//     len(mockedLogger.InfofCalls())
func (mock *LoggerMock) InfofCalls() []struct {
	Format string
	V      []interface{}
} {
	var calls []struct {
		Format string
		V      []interface{}
	}
	lockLoggerMockInfof.RLock()
	calls = mock.calls.Infof
	lockLoggerMockInfof.RUnlock()
	return calls
}
