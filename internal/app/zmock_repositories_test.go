// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package app_test

import (
	"context"
	"github.com/bruli/raspberryWaterSystem/internal/app"
	"github.com/bruli/raspberryWaterSystem/internal/domain/program"
	"github.com/bruli/raspberryWaterSystem/internal/domain/status"
	"github.com/bruli/raspberryWaterSystem/internal/domain/zone"
	"sync"
)

// Ensure, that ZoneRepositoryMock does implement app.ZoneRepository.
// If this is not the case, regenerate this file with moq.
var _ app.ZoneRepository = &ZoneRepositoryMock{}

// ZoneRepositoryMock is a mock implementation of app.ZoneRepository.
//
//	func TestSomethingThatUsesZoneRepository(t *testing.T) {
//
//		// make and configure a mocked app.ZoneRepository
//		mockedZoneRepository := &ZoneRepositoryMock{
//			FindAllFunc: func(ctx context.Context) ([]zone.Zone, error) {
//				panic("mock out the FindAll method")
//			},
//			FindByIDFunc: func(ctx context.Context, id string) (*zone.Zone, error) {
//				panic("mock out the FindByID method")
//			},
//			RemoveFunc: func(ctx context.Context, zo *zone.Zone) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, zo *zone.Zone) error {
//				panic("mock out the Save method")
//			},
//			UpdateFunc: func(ctx context.Context, zo *zone.Zone) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedZoneRepository in code that requires app.ZoneRepository
//		// and then make assertions.
//
//	}
type ZoneRepositoryMock struct {
	// FindAllFunc mocks the FindAll method.
	FindAllFunc func(ctx context.Context) ([]zone.Zone, error)

	// FindByIDFunc mocks the FindByID method.
	FindByIDFunc func(ctx context.Context, id string) (*zone.Zone, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, zo *zone.Zone) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, zo *zone.Zone) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, zo *zone.Zone) error

	// calls tracks calls to the methods.
	calls struct {
		// FindAll holds details about calls to the FindAll method.
		FindAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindByID holds details about calls to the FindByID method.
		FindByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Zo is the zo argument value.
			Zo *zone.Zone
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Zo is the zo argument value.
			Zo *zone.Zone
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Zo is the zo argument value.
			Zo *zone.Zone
		}
	}
	lockFindAll  sync.RWMutex
	lockFindByID sync.RWMutex
	lockRemove   sync.RWMutex
	lockSave     sync.RWMutex
	lockUpdate   sync.RWMutex
}

// FindAll calls FindAllFunc.
func (mock *ZoneRepositoryMock) FindAll(ctx context.Context) ([]zone.Zone, error) {
	if mock.FindAllFunc == nil {
		panic("ZoneRepositoryMock.FindAllFunc: method is nil but ZoneRepository.FindAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindAll.Lock()
	mock.calls.FindAll = append(mock.calls.FindAll, callInfo)
	mock.lockFindAll.Unlock()
	return mock.FindAllFunc(ctx)
}

// FindAllCalls gets all the calls that were made to FindAll.
// Check the length with:
//
//	len(mockedZoneRepository.FindAllCalls())
func (mock *ZoneRepositoryMock) FindAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindAll.RLock()
	calls = mock.calls.FindAll
	mock.lockFindAll.RUnlock()
	return calls
}

// FindByID calls FindByIDFunc.
func (mock *ZoneRepositoryMock) FindByID(ctx context.Context, id string) (*zone.Zone, error) {
	if mock.FindByIDFunc == nil {
		panic("ZoneRepositoryMock.FindByIDFunc: method is nil but ZoneRepository.FindByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFindByID.Lock()
	mock.calls.FindByID = append(mock.calls.FindByID, callInfo)
	mock.lockFindByID.Unlock()
	return mock.FindByIDFunc(ctx, id)
}

// FindByIDCalls gets all the calls that were made to FindByID.
// Check the length with:
//
//	len(mockedZoneRepository.FindByIDCalls())
func (mock *ZoneRepositoryMock) FindByIDCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockFindByID.RLock()
	calls = mock.calls.FindByID
	mock.lockFindByID.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *ZoneRepositoryMock) Remove(ctx context.Context, zo *zone.Zone) error {
	if mock.RemoveFunc == nil {
		panic("ZoneRepositoryMock.RemoveFunc: method is nil but ZoneRepository.Remove was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Zo  *zone.Zone
	}{
		Ctx: ctx,
		Zo:  zo,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(ctx, zo)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedZoneRepository.RemoveCalls())
func (mock *ZoneRepositoryMock) RemoveCalls() []struct {
	Ctx context.Context
	Zo  *zone.Zone
} {
	var calls []struct {
		Ctx context.Context
		Zo  *zone.Zone
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *ZoneRepositoryMock) Save(ctx context.Context, zo *zone.Zone) error {
	if mock.SaveFunc == nil {
		panic("ZoneRepositoryMock.SaveFunc: method is nil but ZoneRepository.Save was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Zo  *zone.Zone
	}{
		Ctx: ctx,
		Zo:  zo,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, zo)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedZoneRepository.SaveCalls())
func (mock *ZoneRepositoryMock) SaveCalls() []struct {
	Ctx context.Context
	Zo  *zone.Zone
} {
	var calls []struct {
		Ctx context.Context
		Zo  *zone.Zone
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ZoneRepositoryMock) Update(ctx context.Context, zo *zone.Zone) error {
	if mock.UpdateFunc == nil {
		panic("ZoneRepositoryMock.UpdateFunc: method is nil but ZoneRepository.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Zo  *zone.Zone
	}{
		Ctx: ctx,
		Zo:  zo,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, zo)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedZoneRepository.UpdateCalls())
func (mock *ZoneRepositoryMock) UpdateCalls() []struct {
	Ctx context.Context
	Zo  *zone.Zone
} {
	var calls []struct {
		Ctx context.Context
		Zo  *zone.Zone
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that TemperatureRepositoryMock does implement app.TemperatureRepository.
// If this is not the case, regenerate this file with moq.
var _ app.TemperatureRepository = &TemperatureRepositoryMock{}

// TemperatureRepositoryMock is a mock implementation of app.TemperatureRepository.
//
//	func TestSomethingThatUsesTemperatureRepository(t *testing.T) {
//
//		// make and configure a mocked app.TemperatureRepository
//		mockedTemperatureRepository := &TemperatureRepositoryMock{
//			FindFunc: func(ctx context.Context) (float32, float32, error) {
//				panic("mock out the Find method")
//			},
//		}
//
//		// use mockedTemperatureRepository in code that requires app.TemperatureRepository
//		// and then make assertions.
//
//	}
type TemperatureRepositoryMock struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context) (float32, float32, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockFind sync.RWMutex
}

// Find calls FindFunc.
func (mock *TemperatureRepositoryMock) Find(ctx context.Context) (float32, float32, error) {
	if mock.FindFunc == nil {
		panic("TemperatureRepositoryMock.FindFunc: method is nil but TemperatureRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedTemperatureRepository.FindCalls())
func (mock *TemperatureRepositoryMock) FindCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// Ensure, that RainRepositoryMock does implement app.RainRepository.
// If this is not the case, regenerate this file with moq.
var _ app.RainRepository = &RainRepositoryMock{}

// RainRepositoryMock is a mock implementation of app.RainRepository.
//
//	func TestSomethingThatUsesRainRepository(t *testing.T) {
//
//		// make and configure a mocked app.RainRepository
//		mockedRainRepository := &RainRepositoryMock{
//			FindFunc: func(ctx context.Context) (bool, error) {
//				panic("mock out the Find method")
//			},
//		}
//
//		// use mockedRainRepository in code that requires app.RainRepository
//		// and then make assertions.
//
//	}
type RainRepositoryMock struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockFind sync.RWMutex
}

// Find calls FindFunc.
func (mock *RainRepositoryMock) Find(ctx context.Context) (bool, error) {
	if mock.FindFunc == nil {
		panic("RainRepositoryMock.FindFunc: method is nil but RainRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedRainRepository.FindCalls())
func (mock *RainRepositoryMock) FindCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// Ensure, that StatusRepositoryMock does implement app.StatusRepository.
// If this is not the case, regenerate this file with moq.
var _ app.StatusRepository = &StatusRepositoryMock{}

// StatusRepositoryMock is a mock implementation of app.StatusRepository.
//
//	func TestSomethingThatUsesStatusRepository(t *testing.T) {
//
//		// make and configure a mocked app.StatusRepository
//		mockedStatusRepository := &StatusRepositoryMock{
//			FindFunc: func(ctx context.Context) (status.Status, error) {
//				panic("mock out the Find method")
//			},
//			SaveFunc: func(ctx context.Context, st status.Status) error {
//				panic("mock out the Save method")
//			},
//			UpdateFunc: func(ctx context.Context, st status.Status) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedStatusRepository in code that requires app.StatusRepository
//		// and then make assertions.
//
//	}
type StatusRepositoryMock struct {
	// FindFunc mocks the Find method.
	FindFunc func(ctx context.Context) (status.Status, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, st status.Status) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, st status.Status) error

	// calls tracks calls to the methods.
	calls struct {
		// Find holds details about calls to the Find method.
		Find []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// St is the st argument value.
			St status.Status
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// St is the st argument value.
			St status.Status
		}
	}
	lockFind   sync.RWMutex
	lockSave   sync.RWMutex
	lockUpdate sync.RWMutex
}

// Find calls FindFunc.
func (mock *StatusRepositoryMock) Find(ctx context.Context) (status.Status, error) {
	if mock.FindFunc == nil {
		panic("StatusRepositoryMock.FindFunc: method is nil but StatusRepository.Find was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFind.Lock()
	mock.calls.Find = append(mock.calls.Find, callInfo)
	mock.lockFind.Unlock()
	return mock.FindFunc(ctx)
}

// FindCalls gets all the calls that were made to Find.
// Check the length with:
//
//	len(mockedStatusRepository.FindCalls())
func (mock *StatusRepositoryMock) FindCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFind.RLock()
	calls = mock.calls.Find
	mock.lockFind.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *StatusRepositoryMock) Save(ctx context.Context, st status.Status) error {
	if mock.SaveFunc == nil {
		panic("StatusRepositoryMock.SaveFunc: method is nil but StatusRepository.Save was just called")
	}
	callInfo := struct {
		Ctx context.Context
		St  status.Status
	}{
		Ctx: ctx,
		St:  st,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, st)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedStatusRepository.SaveCalls())
func (mock *StatusRepositoryMock) SaveCalls() []struct {
	Ctx context.Context
	St  status.Status
} {
	var calls []struct {
		Ctx context.Context
		St  status.Status
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *StatusRepositoryMock) Update(ctx context.Context, st status.Status) error {
	if mock.UpdateFunc == nil {
		panic("StatusRepositoryMock.UpdateFunc: method is nil but StatusRepository.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		St  status.Status
	}{
		Ctx: ctx,
		St:  st,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, st)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedStatusRepository.UpdateCalls())
func (mock *StatusRepositoryMock) UpdateCalls() []struct {
	Ctx context.Context
	St  status.Status
} {
	var calls []struct {
		Ctx context.Context
		St  status.Status
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that ProgramRepositoryMock does implement app.ProgramRepository.
// If this is not the case, regenerate this file with moq.
var _ app.ProgramRepository = &ProgramRepositoryMock{}

// ProgramRepositoryMock is a mock implementation of app.ProgramRepository.
//
//	func TestSomethingThatUsesProgramRepository(t *testing.T) {
//
//		// make and configure a mocked app.ProgramRepository
//		mockedProgramRepository := &ProgramRepositoryMock{
//			FindAllFunc: func(ctx context.Context) ([]program.Program, error) {
//				panic("mock out the FindAll method")
//			},
//			FindByHourFunc: func(ctx context.Context, hour *program.Hour) (*program.Program, error) {
//				panic("mock out the FindByHour method")
//			},
//			RemoveFunc: func(ctx context.Context, hour *program.Hour) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, programs *program.Program) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedProgramRepository in code that requires app.ProgramRepository
//		// and then make assertions.
//
//	}
type ProgramRepositoryMock struct {
	// FindAllFunc mocks the FindAll method.
	FindAllFunc func(ctx context.Context) ([]program.Program, error)

	// FindByHourFunc mocks the FindByHour method.
	FindByHourFunc func(ctx context.Context, hour *program.Hour) (*program.Program, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, hour *program.Hour) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, programs *program.Program) error

	// calls tracks calls to the methods.
	calls struct {
		// FindAll holds details about calls to the FindAll method.
		FindAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindByHour holds details about calls to the FindByHour method.
		FindByHour []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hour is the hour argument value.
			Hour *program.Hour
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hour is the hour argument value.
			Hour *program.Hour
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Programs is the programs argument value.
			Programs *program.Program
		}
	}
	lockFindAll    sync.RWMutex
	lockFindByHour sync.RWMutex
	lockRemove     sync.RWMutex
	lockSave       sync.RWMutex
}

// FindAll calls FindAllFunc.
func (mock *ProgramRepositoryMock) FindAll(ctx context.Context) ([]program.Program, error) {
	if mock.FindAllFunc == nil {
		panic("ProgramRepositoryMock.FindAllFunc: method is nil but ProgramRepository.FindAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindAll.Lock()
	mock.calls.FindAll = append(mock.calls.FindAll, callInfo)
	mock.lockFindAll.Unlock()
	return mock.FindAllFunc(ctx)
}

// FindAllCalls gets all the calls that were made to FindAll.
// Check the length with:
//
//	len(mockedProgramRepository.FindAllCalls())
func (mock *ProgramRepositoryMock) FindAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindAll.RLock()
	calls = mock.calls.FindAll
	mock.lockFindAll.RUnlock()
	return calls
}

// FindByHour calls FindByHourFunc.
func (mock *ProgramRepositoryMock) FindByHour(ctx context.Context, hour *program.Hour) (*program.Program, error) {
	if mock.FindByHourFunc == nil {
		panic("ProgramRepositoryMock.FindByHourFunc: method is nil but ProgramRepository.FindByHour was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hour *program.Hour
	}{
		Ctx:  ctx,
		Hour: hour,
	}
	mock.lockFindByHour.Lock()
	mock.calls.FindByHour = append(mock.calls.FindByHour, callInfo)
	mock.lockFindByHour.Unlock()
	return mock.FindByHourFunc(ctx, hour)
}

// FindByHourCalls gets all the calls that were made to FindByHour.
// Check the length with:
//
//	len(mockedProgramRepository.FindByHourCalls())
func (mock *ProgramRepositoryMock) FindByHourCalls() []struct {
	Ctx  context.Context
	Hour *program.Hour
} {
	var calls []struct {
		Ctx  context.Context
		Hour *program.Hour
	}
	mock.lockFindByHour.RLock()
	calls = mock.calls.FindByHour
	mock.lockFindByHour.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *ProgramRepositoryMock) Remove(ctx context.Context, hour *program.Hour) error {
	if mock.RemoveFunc == nil {
		panic("ProgramRepositoryMock.RemoveFunc: method is nil but ProgramRepository.Remove was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Hour *program.Hour
	}{
		Ctx:  ctx,
		Hour: hour,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(ctx, hour)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedProgramRepository.RemoveCalls())
func (mock *ProgramRepositoryMock) RemoveCalls() []struct {
	Ctx  context.Context
	Hour *program.Hour
} {
	var calls []struct {
		Ctx  context.Context
		Hour *program.Hour
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *ProgramRepositoryMock) Save(ctx context.Context, programs *program.Program) error {
	if mock.SaveFunc == nil {
		panic("ProgramRepositoryMock.SaveFunc: method is nil but ProgramRepository.Save was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Programs *program.Program
	}{
		Ctx:      ctx,
		Programs: programs,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, programs)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedProgramRepository.SaveCalls())
func (mock *ProgramRepositoryMock) SaveCalls() []struct {
	Ctx      context.Context
	Programs *program.Program
} {
	var calls []struct {
		Ctx      context.Context
		Programs *program.Program
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that WeeklyProgramRepositoryMock does implement app.WeeklyProgramRepository.
// If this is not the case, regenerate this file with moq.
var _ app.WeeklyProgramRepository = &WeeklyProgramRepositoryMock{}

// WeeklyProgramRepositoryMock is a mock implementation of app.WeeklyProgramRepository.
//
//	func TestSomethingThatUsesWeeklyProgramRepository(t *testing.T) {
//
//		// make and configure a mocked app.WeeklyProgramRepository
//		mockedWeeklyProgramRepository := &WeeklyProgramRepositoryMock{
//			FindAllFunc: func(ctx context.Context) ([]program.Weekly, error) {
//				panic("mock out the FindAll method")
//			},
//			FindByDayFunc: func(ctx context.Context, day *program.WeekDay) (*program.Weekly, error) {
//				panic("mock out the FindByDay method")
//			},
//			FindByDayAndHourFunc: func(ctx context.Context, day *program.WeekDay, hour *program.Hour) (*program.Weekly, error) {
//				panic("mock out the FindByDayAndHour method")
//			},
//			RemoveFunc: func(ctx context.Context, day *program.WeekDay) error {
//				panic("mock out the Remove method")
//			},
//			SaveFunc: func(ctx context.Context, programMoqParam *program.Weekly) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedWeeklyProgramRepository in code that requires app.WeeklyProgramRepository
//		// and then make assertions.
//
//	}
type WeeklyProgramRepositoryMock struct {
	// FindAllFunc mocks the FindAll method.
	FindAllFunc func(ctx context.Context) ([]program.Weekly, error)

	// FindByDayFunc mocks the FindByDay method.
	FindByDayFunc func(ctx context.Context, day *program.WeekDay) (*program.Weekly, error)

	// FindByDayAndHourFunc mocks the FindByDayAndHour method.
	FindByDayAndHourFunc func(ctx context.Context, day *program.WeekDay, hour *program.Hour) (*program.Weekly, error)

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(ctx context.Context, day *program.WeekDay) error

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, programMoqParam *program.Weekly) error

	// calls tracks calls to the methods.
	calls struct {
		// FindAll holds details about calls to the FindAll method.
		FindAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindByDay holds details about calls to the FindByDay method.
		FindByDay []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Day is the day argument value.
			Day *program.WeekDay
		}
		// FindByDayAndHour holds details about calls to the FindByDayAndHour method.
		FindByDayAndHour []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Day is the day argument value.
			Day *program.WeekDay
			// Hour is the hour argument value.
			Hour *program.Hour
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Day is the day argument value.
			Day *program.WeekDay
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProgramMoqParam is the programMoqParam argument value.
			ProgramMoqParam *program.Weekly
		}
	}
	lockFindAll          sync.RWMutex
	lockFindByDay        sync.RWMutex
	lockFindByDayAndHour sync.RWMutex
	lockRemove           sync.RWMutex
	lockSave             sync.RWMutex
}

// FindAll calls FindAllFunc.
func (mock *WeeklyProgramRepositoryMock) FindAll(ctx context.Context) ([]program.Weekly, error) {
	if mock.FindAllFunc == nil {
		panic("WeeklyProgramRepositoryMock.FindAllFunc: method is nil but WeeklyProgramRepository.FindAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindAll.Lock()
	mock.calls.FindAll = append(mock.calls.FindAll, callInfo)
	mock.lockFindAll.Unlock()
	return mock.FindAllFunc(ctx)
}

// FindAllCalls gets all the calls that were made to FindAll.
// Check the length with:
//
//	len(mockedWeeklyProgramRepository.FindAllCalls())
func (mock *WeeklyProgramRepositoryMock) FindAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindAll.RLock()
	calls = mock.calls.FindAll
	mock.lockFindAll.RUnlock()
	return calls
}

// FindByDay calls FindByDayFunc.
func (mock *WeeklyProgramRepositoryMock) FindByDay(ctx context.Context, day *program.WeekDay) (*program.Weekly, error) {
	if mock.FindByDayFunc == nil {
		panic("WeeklyProgramRepositoryMock.FindByDayFunc: method is nil but WeeklyProgramRepository.FindByDay was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Day *program.WeekDay
	}{
		Ctx: ctx,
		Day: day,
	}
	mock.lockFindByDay.Lock()
	mock.calls.FindByDay = append(mock.calls.FindByDay, callInfo)
	mock.lockFindByDay.Unlock()
	return mock.FindByDayFunc(ctx, day)
}

// FindByDayCalls gets all the calls that were made to FindByDay.
// Check the length with:
//
//	len(mockedWeeklyProgramRepository.FindByDayCalls())
func (mock *WeeklyProgramRepositoryMock) FindByDayCalls() []struct {
	Ctx context.Context
	Day *program.WeekDay
} {
	var calls []struct {
		Ctx context.Context
		Day *program.WeekDay
	}
	mock.lockFindByDay.RLock()
	calls = mock.calls.FindByDay
	mock.lockFindByDay.RUnlock()
	return calls
}

// FindByDayAndHour calls FindByDayAndHourFunc.
func (mock *WeeklyProgramRepositoryMock) FindByDayAndHour(ctx context.Context, day *program.WeekDay, hour *program.Hour) (*program.Weekly, error) {
	if mock.FindByDayAndHourFunc == nil {
		panic("WeeklyProgramRepositoryMock.FindByDayAndHourFunc: method is nil but WeeklyProgramRepository.FindByDayAndHour was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Day  *program.WeekDay
		Hour *program.Hour
	}{
		Ctx:  ctx,
		Day:  day,
		Hour: hour,
	}
	mock.lockFindByDayAndHour.Lock()
	mock.calls.FindByDayAndHour = append(mock.calls.FindByDayAndHour, callInfo)
	mock.lockFindByDayAndHour.Unlock()
	return mock.FindByDayAndHourFunc(ctx, day, hour)
}

// FindByDayAndHourCalls gets all the calls that were made to FindByDayAndHour.
// Check the length with:
//
//	len(mockedWeeklyProgramRepository.FindByDayAndHourCalls())
func (mock *WeeklyProgramRepositoryMock) FindByDayAndHourCalls() []struct {
	Ctx  context.Context
	Day  *program.WeekDay
	Hour *program.Hour
} {
	var calls []struct {
		Ctx  context.Context
		Day  *program.WeekDay
		Hour *program.Hour
	}
	mock.lockFindByDayAndHour.RLock()
	calls = mock.calls.FindByDayAndHour
	mock.lockFindByDayAndHour.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *WeeklyProgramRepositoryMock) Remove(ctx context.Context, day *program.WeekDay) error {
	if mock.RemoveFunc == nil {
		panic("WeeklyProgramRepositoryMock.RemoveFunc: method is nil but WeeklyProgramRepository.Remove was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Day *program.WeekDay
	}{
		Ctx: ctx,
		Day: day,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	return mock.RemoveFunc(ctx, day)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedWeeklyProgramRepository.RemoveCalls())
func (mock *WeeklyProgramRepositoryMock) RemoveCalls() []struct {
	Ctx context.Context
	Day *program.WeekDay
} {
	var calls []struct {
		Ctx context.Context
		Day *program.WeekDay
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *WeeklyProgramRepositoryMock) Save(ctx context.Context, programMoqParam *program.Weekly) error {
	if mock.SaveFunc == nil {
		panic("WeeklyProgramRepositoryMock.SaveFunc: method is nil but WeeklyProgramRepository.Save was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		ProgramMoqParam *program.Weekly
	}{
		Ctx:             ctx,
		ProgramMoqParam: programMoqParam,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, programMoqParam)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedWeeklyProgramRepository.SaveCalls())
func (mock *WeeklyProgramRepositoryMock) SaveCalls() []struct {
	Ctx             context.Context
	ProgramMoqParam *program.Weekly
} {
	var calls []struct {
		Ctx             context.Context
		ProgramMoqParam *program.Weekly
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that TemperatureProgramRepositoryMock does implement app.TemperatureProgramRepository.
// If this is not the case, regenerate this file with moq.
var _ app.TemperatureProgramRepository = &TemperatureProgramRepositoryMock{}

// TemperatureProgramRepositoryMock is a mock implementation of app.TemperatureProgramRepository.
//
//	func TestSomethingThatUsesTemperatureProgramRepository(t *testing.T) {
//
//		// make and configure a mocked app.TemperatureProgramRepository
//		mockedTemperatureProgramRepository := &TemperatureProgramRepositoryMock{
//			FindAllFunc: func(ctx context.Context) ([]program.Temperature, error) {
//				panic("mock out the FindAll method")
//			},
//			FindByTemperatureAndHourFunc: func(ctx context.Context, temperature float32, hour program.Hour) (program.Temperature, error) {
//				panic("mock out the FindByTemperatureAndHour method")
//			},
//			SaveFunc: func(ctx context.Context, programs []program.Temperature) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedTemperatureProgramRepository in code that requires app.TemperatureProgramRepository
//		// and then make assertions.
//
//	}
type TemperatureProgramRepositoryMock struct {
	// FindAllFunc mocks the FindAll method.
	FindAllFunc func(ctx context.Context) ([]program.Temperature, error)

	// FindByTemperatureAndHourFunc mocks the FindByTemperatureAndHour method.
	FindByTemperatureAndHourFunc func(ctx context.Context, temperature float32, hour program.Hour) (program.Temperature, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, programs []program.Temperature) error

	// calls tracks calls to the methods.
	calls struct {
		// FindAll holds details about calls to the FindAll method.
		FindAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FindByTemperatureAndHour holds details about calls to the FindByTemperatureAndHour method.
		FindByTemperatureAndHour []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Temperature is the temperature argument value.
			Temperature float32
			// Hour is the hour argument value.
			Hour program.Hour
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Programs is the programs argument value.
			Programs []program.Temperature
		}
	}
	lockFindAll                  sync.RWMutex
	lockFindByTemperatureAndHour sync.RWMutex
	lockSave                     sync.RWMutex
}

// FindAll calls FindAllFunc.
func (mock *TemperatureProgramRepositoryMock) FindAll(ctx context.Context) ([]program.Temperature, error) {
	if mock.FindAllFunc == nil {
		panic("TemperatureProgramRepositoryMock.FindAllFunc: method is nil but TemperatureProgramRepository.FindAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindAll.Lock()
	mock.calls.FindAll = append(mock.calls.FindAll, callInfo)
	mock.lockFindAll.Unlock()
	return mock.FindAllFunc(ctx)
}

// FindAllCalls gets all the calls that were made to FindAll.
// Check the length with:
//
//	len(mockedTemperatureProgramRepository.FindAllCalls())
func (mock *TemperatureProgramRepositoryMock) FindAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindAll.RLock()
	calls = mock.calls.FindAll
	mock.lockFindAll.RUnlock()
	return calls
}

// FindByTemperatureAndHour calls FindByTemperatureAndHourFunc.
func (mock *TemperatureProgramRepositoryMock) FindByTemperatureAndHour(ctx context.Context, temperature float32, hour program.Hour) (program.Temperature, error) {
	if mock.FindByTemperatureAndHourFunc == nil {
		panic("TemperatureProgramRepositoryMock.FindByTemperatureAndHourFunc: method is nil but TemperatureProgramRepository.FindByTemperatureAndHour was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Temperature float32
		Hour        program.Hour
	}{
		Ctx:         ctx,
		Temperature: temperature,
		Hour:        hour,
	}
	mock.lockFindByTemperatureAndHour.Lock()
	mock.calls.FindByTemperatureAndHour = append(mock.calls.FindByTemperatureAndHour, callInfo)
	mock.lockFindByTemperatureAndHour.Unlock()
	return mock.FindByTemperatureAndHourFunc(ctx, temperature, hour)
}

// FindByTemperatureAndHourCalls gets all the calls that were made to FindByTemperatureAndHour.
// Check the length with:
//
//	len(mockedTemperatureProgramRepository.FindByTemperatureAndHourCalls())
func (mock *TemperatureProgramRepositoryMock) FindByTemperatureAndHourCalls() []struct {
	Ctx         context.Context
	Temperature float32
	Hour        program.Hour
} {
	var calls []struct {
		Ctx         context.Context
		Temperature float32
		Hour        program.Hour
	}
	mock.lockFindByTemperatureAndHour.RLock()
	calls = mock.calls.FindByTemperatureAndHour
	mock.lockFindByTemperatureAndHour.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *TemperatureProgramRepositoryMock) Save(ctx context.Context, programs []program.Temperature) error {
	if mock.SaveFunc == nil {
		panic("TemperatureProgramRepositoryMock.SaveFunc: method is nil but TemperatureProgramRepository.Save was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Programs []program.Temperature
	}{
		Ctx:      ctx,
		Programs: programs,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, programs)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedTemperatureProgramRepository.SaveCalls())
func (mock *TemperatureProgramRepositoryMock) SaveCalls() []struct {
	Ctx      context.Context
	Programs []program.Temperature
} {
	var calls []struct {
		Ctx      context.Context
		Programs []program.Temperature
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that ExecutionLogRepositoryMock does implement app.ExecutionLogRepository.
// If this is not the case, regenerate this file with moq.
var _ app.ExecutionLogRepository = &ExecutionLogRepositoryMock{}

// ExecutionLogRepositoryMock is a mock implementation of app.ExecutionLogRepository.
//
//	func TestSomethingThatUsesExecutionLogRepository(t *testing.T) {
//
//		// make and configure a mocked app.ExecutionLogRepository
//		mockedExecutionLogRepository := &ExecutionLogRepositoryMock{
//			FindAllFunc: func(ctx context.Context) ([]program.ExecutionLog, error) {
//				panic("mock out the FindAll method")
//			},
//			SaveFunc: func(ctx context.Context, logs []program.ExecutionLog) error {
//				panic("mock out the Save method")
//			},
//		}
//
//		// use mockedExecutionLogRepository in code that requires app.ExecutionLogRepository
//		// and then make assertions.
//
//	}
type ExecutionLogRepositoryMock struct {
	// FindAllFunc mocks the FindAll method.
	FindAllFunc func(ctx context.Context) ([]program.ExecutionLog, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, logs []program.ExecutionLog) error

	// calls tracks calls to the methods.
	calls struct {
		// FindAll holds details about calls to the FindAll method.
		FindAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Logs is the logs argument value.
			Logs []program.ExecutionLog
		}
	}
	lockFindAll sync.RWMutex
	lockSave    sync.RWMutex
}

// FindAll calls FindAllFunc.
func (mock *ExecutionLogRepositoryMock) FindAll(ctx context.Context) ([]program.ExecutionLog, error) {
	if mock.FindAllFunc == nil {
		panic("ExecutionLogRepositoryMock.FindAllFunc: method is nil but ExecutionLogRepository.FindAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFindAll.Lock()
	mock.calls.FindAll = append(mock.calls.FindAll, callInfo)
	mock.lockFindAll.Unlock()
	return mock.FindAllFunc(ctx)
}

// FindAllCalls gets all the calls that were made to FindAll.
// Check the length with:
//
//	len(mockedExecutionLogRepository.FindAllCalls())
func (mock *ExecutionLogRepositoryMock) FindAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFindAll.RLock()
	calls = mock.calls.FindAll
	mock.lockFindAll.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *ExecutionLogRepositoryMock) Save(ctx context.Context, logs []program.ExecutionLog) error {
	if mock.SaveFunc == nil {
		panic("ExecutionLogRepositoryMock.SaveFunc: method is nil but ExecutionLogRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Logs []program.ExecutionLog
	}{
		Ctx:  ctx,
		Logs: logs,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, logs)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedExecutionLogRepository.SaveCalls())
func (mock *ExecutionLogRepositoryMock) SaveCalls() []struct {
	Ctx  context.Context
	Logs []program.ExecutionLog
} {
	var calls []struct {
		Ctx  context.Context
		Logs []program.ExecutionLog
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}
