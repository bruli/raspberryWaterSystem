// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package file

import (
	"sync"
)

var (
	lockwriterMockwrite sync.RWMutex
)

// Ensure, that writerMock does implement writer.
// If this is not the case, regenerate this file with moq.
var _ writer = &writerMock{}

// writerMock is a mock implementation of writer.
//
//     func TestSomethingThatUseswriter(t *testing.T) {
//
//         // make and configure a mocked writer
//         mockedwriter := &writerMock{
//             writeFunc: func(d []byte) error {
// 	               panic("mock out the write method")
//             },
//         }
//
//         // use mockedwriter in code that requires writer
//         // and then make assertions.
//
//     }
type writerMock struct {
	// writeFunc mocks the write method.
	writeFunc func(d []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// write holds details about calls to the write method.
		write []struct {
			// D is the d argument value.
			D []byte
		}
	}
}

// write calls writeFunc.
func (mock *writerMock) write(d []byte) error {
	if mock.writeFunc == nil {
		panic("writerMock.writeFunc: method is nil but writer.write was just called")
	}
	callInfo := struct {
		D []byte
	}{
		D: d,
	}
	lockwriterMockwrite.Lock()
	mock.calls.write = append(mock.calls.write, callInfo)
	lockwriterMockwrite.Unlock()
	return mock.writeFunc(d)
}

// writeCalls gets all the calls that were made to write.
// Check the length with:
//     len(mockedwriter.writeCalls())
func (mock *writerMock) writeCalls() []struct {
	D []byte
} {
	var calls []struct {
		D []byte
	}
	lockwriterMockwrite.RLock()
	calls = mock.calls.write
	lockwriterMockwrite.RUnlock()
	return calls
}
